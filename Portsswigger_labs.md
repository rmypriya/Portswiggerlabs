JWT ATTACKS - PORTSWIGGER LABS: Total No of Labs - 8 Completed - 6

1.JWT AUTHENTICATION BYPASS VIA UNVERIFIED SIGNATURE: Technique used:
Change the "sub" value in payload part of the jwt token.since we are
bypassing via unverified signature.Here, the server did not verify the
signature. So we can eassily change the header and paylaod part of a jwt
token.

2.JWT AUTHENTICATION BYPASS VIA FLAWED SIGNATURE: Technique used: Unlike
the previous case, here the server verifies the signature but not
properly. So we can eassily bypass the signature verification by
changing the header & the payload part.

3.JWT AUTHENTICATION BYPASS VIA JWK HEADER INJECTION: Technique used:
Here, the malicious jwk is injected into the header part through which
we can easily manipulate the server and loged in as admin. Note: JWK can
be generated by using json editor in burpApp.

4.JWT AUTHENTICATION BYPASS VIA JKU HEADER INJECION: Technique used:
Here the jku was injected into the header part and also match the 'kid'
value in the header with the jwk set's 'kid' value, So that we can
manipulate the server and access the admin panel. Note: First generate a
jwk set and paste it and store it into the exploit server.Then we have
to copy the url of the exploit server and use it for the jku parameter.

5.JWT AUTHENTICATION BYPASS VIA KID HEADER PATH TRAVERSAL: Technique
used: Here we first created a symetric key and then change the payload
part of jwt and sign them using the genrated symetric key, then we can
successfully access the admin panel. Note: Condition: Here we have to
keep the key value as 'null' in the created symetric key.

6.JWT AUTHENTICATION BYPASS VIA ALGORITHM CONFUSION: Technique used: Get
the public key from the server and using this public key, we created one
jwk set.With the values of jwk, create one symetric key.Now sign our jwt
token with the generated symetric key. Note: We can get the server's
public key using '/jwks.json'.

HTTP REQUEST SMUGGLING ATTACKS: Total No of Labs - 21 Completed - 14

1.HTTP REQUEST SMUGGLING, CONFIRMING A CL.TE VULNERABILITY VIA
DIFFERENTIAL RESPONSES: Technique used: The front end server supports
Content Length(CL) encoding, so we can send our smuggled http request
using CL encoding. Note: To smuggle a http request we must use HTTP/1.1
protocol. Condition:before sending the request uncheck the content
length box in settings.

2.HTTP REQUEST SMUGGLING, CONFIRMING A TE.CL VULNERABILITY VIA
DIFFERENTIAL RESPONSES: Technique used: The front end server supports
Transfer Encoding, so we can send our smuggled http request using TE.
Note: To smuggle a http request we must use HTTP/1.1 protocol.
Condition:before sending the request uncheck the content length box in
settings.

3.EXPLOITING HTTP REQUEST SMUGGLING TO BYPASS THE FRONT END SECURITY
CONTROLS, CL.TE VULNERABILITY. Technique used: Here we access the admin
panel through a smuggling request and the smuggling request can be send
to back end server by using CL encoding(since the front end server
supports CL encoding) Note: To smuggle a http request we must use
HTTP/1.1 protocol. Condition:before sending the request uncheck the
content length box in settings.

4.EXPLOITING HTTP REQUEST SMUGGLING TO BYPASS THE FRONT END SECURITY
CONTROLS, TE.CL VULNERABILITY. Technique used: Here we access the admin
panel through a smuggling request and the smuggling request can be send
to back end server by using the TE(Since the front end server supports
TE method) Note: To smuggle a http request we must use HTTP/1.1
protocol. Condition:before sending the request uncheck the content
length box in settings.

5.EXPLOITING HTTP REQUEST SMUGGLING TO CAPTURE OTHER USER'S REQUEST:
Technique used: Here the front end server supports only the CL encoding
method, so we smuggled the next user's request by using the CL method
and drop our smuggled request to the back end server. Note: To smuggle a
http request we must use HTTP/1.1 protocol.

6.EXPLOITING HTTP REQUEST SMUGGLING TO REVEAL FRONT-END REQUEST
REWRITING: Technique used: Here the admin panel is accessible for only
the IP(127.0.0.1), So we smuggle a request with search parameter and get
the x-forwarded parameter which stores the respective IP address. Then
set the x-forwarded parameter value as 127.0.0.1 and forward the
smuggled request. Note: To smuggle a http request we must use HTTP/1.1
protocol. Condition:before sending the request uncheck the content
length box in settings.

7.EXPLOITING HTTP REQUEST SMUGGLING TO DELIVER REFLECTED XSS: Technique
used: Since the front end server supports CL Encoding method, So we can
insert our smuggled request to reflect xss to the next user. Note: To
smuggle a http request we must use HTTP/1.1 protocol.

8.RESPONSE QUEUE POISIONING VIA H2.TE REQUEST SMUGGLING: Technique used:
Here the front end server supports Transfer encoding method and it also
downgrades the http/2 protocol requests even if they have a correct
length.So here we smuggle our request to access admin panel, in-order to
delete carlos account. Note: To smuggle a request, here we must use
HTTP/2 protocol.

9.H2.CL REQUEST SMUGGLING: Technique used: Here the front end server
supports CL encoding method and it also downgrades the http/2 protocol
requests even if they have a correct length.So here we smuggle our
request in-order to load and execute the malicious javascript into a
victim user's browser. Note: To smuggle a request, here we must use
HTTP/2 protocol.

10.HTTP REQUEST SMUGGLING, BASIC CL.TE VULNERABILITY: Technique used:
Here the front-end server supports CL encoding method & the back-end
server supports TE method. So here we insert our smuggle request using
the CL encoding method. Note: To smuggle a request, here we must use
HTTP/1.1 protocol. Condition:before sending the request uncheck the
content length box in settings.

11.HTTP REQUEST SMUGGLING, BASIC TE.CL VULNERABILITY: Technique used:
Here the front-end server supports TE method & the back-end server
supports CL encoding method. So here we insert our smuggled request
using the TE method. Note: To smuggle a request, here we must use
HTTP/1.1 protocol. Condition:before sending the request uncheck the
content length box in settings.

12.HTTP REQUEST SMUGGLING, BY OBFUSCATING THE TE HEADER: Technique used:
We smuggled our request by manipulating the back-end server with
obfuscated TE method. Note: To smuggle a request, here we must use
HTTP/1.1 protocol. Condition:before sending the request uncheck the
content length box in settings.

13.HTTP/2 REQUEST SPLITTING VIA CRLF INJECTION: Technique used: Here the
front-end server downgrades the http/2 request and didn't sanitize the
headers. So we can smuggle our request by using a header injection,
in-order to access admin panel. Note: To smuggle a request,here we must
use HTTP/2 protocol.

14.HTTP/2 REQUEST SMUGGLING VIA CRLF INJECTION: Technique used: Here the
front-end server downgrades the http/2 request and didn't sanitize the
headers. So we can smuggle our request by using a header injection,
in-order to access another user's account. Note: To smuggle a
request,here we must use HTTP/2 protocol.

PROTOTYPE POLLUTION: Total No of labs - 10 Completed - 8

1.CLIENT-SIDE PROTOTYPE POLLUTION VIA BROWSER APIS: Technique used: Here
the website is vulnerable to DOM XSS, so we inject javascript 'alert'
payload by using prototype pollution method using '**proto**' source and
gadget property.

2.DOM XSS VIA CLIENT SIDE PROTOTYPE POLLUTION: Technique used: Here,
first we have to find out the way to add property and then by using the
'**proto**' source and gadget property we can insert our javascript
payload.

3.DOM XSS VIA AN ALLTERNATIVE PROTOTYPE POLLUTION VECTOR: Technique
used: Here, we have to find out the object.prototype to add arbitary
properties.Next, we have to find the gadget property and insert the
javascript payload.

4.CLIENT SIDE PROTOTYPE POLLUTION VIA FLAWED SANITIZATION: Technique
used: Here the developers sanitize the input parameters but still we can
do DOM XSS using the '\_\_pro\_\_proto**to**' source and gadget
property.

5.PRIVILEGE ESCALATION VIA SERVER SIDE PROTOTYPE POLLUTION: Technique
used: Here, we insert the '**proto**' source and 'isAdmin' gadget into
the request and get the access for the admin pannel.

6.DETECTING SERVER-SIDE PROTOTYPE POLLUTION WITHOUT POLLUTED PROPERTY
REFLECTION: Technique used: Here, first we have to findout the gadget
property and change the value of that gadget in the request and they get
reflected in the response.

7.BYPASSING FLAWED INPUT FILTERS FOR SERVER-SIDE PROTOTYPE POLLUTION:
Technique used: Here, we couldn't use the '**proto**' source directly
due to input filters. So we have to inject our prototype pollution via
'constructor' property.

8.REMOTE CODE EXECUTION VIA SERVER-SIDE PROTOTYPE POLLUTION: Technique
used: Here, we can use '**proto**' source for pollution and inside it we
use 'execArgv' property to do the remote code execution.

SSRF: Total No of labs - 7 Completed - 5

1.BASIC SSRF AGAINST THE LOCAL SERVER: Technique used: The admin panel
is not accessible by the normal user, So here we have to change the
stockApi path to /admin through which we can access the admin pannel.

2.BASIC SSRF AGAINST ANOTHER BACK END SYSYTEM: Technique used: Here the
admin interface is accessible for '192.168.0.x:8000' range. So first we
have to find the admin interface's IP and using this IP we can access
the admin pannel. Note: Inorder to find the admin interface's IP we have
to bruteforce the '192.168.0.x' with the range of '1' to '255'.

3.SSRF WITH BLACKLIST BASED INPUT FILTER: Technique used: Here the admin
pannel is accessible for the localhost but we couldn't use the '/admin'
path directly into the 'stockApi' due to blacklist. So we have to
obfuscate our '/admin' path inorder to get the admin pannel access.
Note: We have to convert the 'a' in '/admin' into double URL encoded.

4.SSRF WITH FILTER BYPASS VIA OPEN REDIRECTION VULNERABILITY: Technique
used: Here we couldn't insert the admin path directly into the stockApi
due to input filters, So we use the 'path' parameter in the stockApi to
access the admin pannel. Note: Here we have to insert our admin path
inside the 'path' parameter.

5.SSRF WITH WHITELIST BASED INPUT FILTER: Technique used: Here, the
admin pannel is accessible for the localhost but we couldn't use the
'/admin' path directly into the 'stockApi' due to whitelist. So we have
to find the whitelisted path and then by using double url encoded for
'\#' we can find the admin path.

SSTI: Total No of Labs - 7 Completed - 5

1.BASIC SERVER SIDE TEMPLATE INJECTION: Technique used: In this lab,
they have used 'ERB' template. So first we have to take a look at 'ruby
documentation' and findout the 'system()' method to execute OS commands
through which we are able to delete carlos account.

2.BASIC SERVER SIDE TEMPLATE INJECTION (CODE-CONTEXT): Technique used:
In this lab, they have used 'Tornado' template. So we have to take a
look at 'Tornado documentation' and findout the 'system()' method to
execute OS commands through which we are able to delete carlos account.

3.SERVER SIDE TEMPLATE INJECTION USING DOCUMENTATION: Technique used:
Here they didn't mention any template engine names that they have used.
So first, we have to findout the template engine through the error
messages. Then reffer the documentation for the respective template
injection inorder to execute the arbitrary commands.

4.SERVER SIDE TEMPLATE INJECTION IN AN UNKNOWN LANGUAGE WITH A
DOCUMENTED EXPLOIT: Technique used: Here we don't know about the
template engine, so we have to identify the template engine and findout
a method to execute the OS commands. Note: We have to convert our code
into URL inoder to delete carlos account.

5.SERVER SIDE TEMPLATE INJECTION WITH INFORMATION DISCLOSURE VIA USER
SUPPLIED OBJECTS: Technique used: First we have to identify the template
engine used through the error message. Then, we have to check the
respective 'documentation' for that template engine to get the debugging
information. From the debug information we can view the 'secrete key'
through which we can solve the lab.

CORS: Total No of Labs - 3 Completed - 3

1.CORS VULNERABILITY WITH BASIC ORIGIN REFLECTION: Technique used: The
website has an insecure cors configuration that it trust all the
origins. Here we are going to get the administrator's api key by using a
javascript code in the exploit server.

2.CORS VULNERABILITY WITH TRUSTED NULL ORIGINS: Technique used: The
website has an insecure cors configuration that it trust the null
origins. Here we are going to get the administrator's api key by using a
javascript code in the exploit server.

3.CORS VULNERABILITHY WITH TRUSTED INSECURE PROTOCOLS: Technique used:
Website has an insecure cors configuration that it trust all the
subdomains regardless of the protocol.Here we are going to get the
administrator's api key by using a javascript code in the exploit
server.

CLICKJACKING: Total No of Labs - 5 Completed - 1

1.BASIC CLICKJACKING WITH BASIC CSRF PROTECTION: Technique used: First
we have to login into the target website. Then in the exploit server we
have to inject a html template which contains the 'iframe' tag through
which we are going to delete the target website's user account.
